package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.DistanceSensor;
import com.qualcomm.hardware.bosch.BNO055IMU;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;

@TeleOp(name="Control Robot", group="Linear OpMode")
public class Program extends LinearOpMode {
    
    private ElapsedTime runtime = new ElapsedTime();
    private DcMotor frontLeftMotor;
    private DcMotor frontRightMotor;
    private DcMotor rearLeftMotor;
    private DcMotor rearRightMotor;
    
    // Variables
    double frontLeftMotorPower = 0;
    double frontRightMotorPower = 0;
    double rearLeftMotorPower = 0;
    double rearRightMotorPower = 0;
    double threshold = 0.2;
    double target = 1;
    double drive = 0;
    double turn = 0;

@Override
    public void runOpMode() {
        
        frontLeftMotor = hardwareMap.get(DcMotor.class, "frontLeftMotor");
        frontRightMotor = hardwareMap.get(DcMotor.class, "frontRightMotor");
        rearLeftMotor = hardwareMap.get(DcMotor.class, "rearLeftMotor");
        rearRightMotor = hardwareMap.get(DcMotor.class, "rearRightMotor");

        // Create a RobotHardware object to be used to access robot hardware.
        // Prefix any hardware functions with "robot." to access this class.
        RobotHardware robot = new RobotHardware(this);
        frontLeftMotor.setDirection(DcMotor.Direction.REVERSE);
        frontRightMotor.setDirection(DcMotor.Direction.FORWARD);
      
      // Put initialization blocks here
      waitForStart();
      
      // Put run blocks here
        frontLeftMotor.setPower(1);
        sleep(500);
        frontLeftMotor.setPower(0);
        
        frontRightMotor.setPower(1);
        sleep(500);
        frontRightMotor.setPower(0);
        
        rearLeftMotor.setPower(1);
        sleep(500);
        rearLeftMotor.setPower(0);
          
        rearRightMotor.setPower(1);
        sleep(500);
        rearRightMotor.setPower(0);
        
      
      while (opModeIsActive()) {
        // Put loop blocks here
        
        // left stick to go forward, and right stick to turn.
        drive = -gamepad1.left_stick_y;
        turn  =  gamepad1.right_stick_x;
        robot.driveRobot(drive, turn);

        public void driveRobot(double Drive, double Turn) {

        // Combine drive and turn for blended motion.
        double left  = Drive + Turn;
        double right = Drive - Turn;

        // Scale the values so neither exceed +/- 1.0
        double max = Math.max(Math.abs(left), Math.abs(right));
        if (max > 1.0)
        {
            left /= max;
            right /= max;
        }

        // Use existing function to drive both wheels.
        setDrivePower(left, right);

    }

    /*
        if (Math.abs(gamepad1.left_stick_y + target) < threshold ) {
    
            // Move Straight
            frontLeftMotor.setPower(1);
            frontRightMotor.setPower(-1);
    
        } else if (Math.abs(gamepad1.left_stick_y - target) < threshold ) {
    
            // Move Backwards
            frontLeftMotor.setPower(-1);
            frontRightMotor.setPower(1);
    
        } else if (Math.abs(gamepad1.right_stick_x + target) < threshold ) {
    
            // Turn Right
            frontLeftMotor.setPower(-1);
            frontRightMotor.setPower(-1);
    
        } else if (Math.abs(gamepad1.right_stick_x - target) < threshold ) {
    
            // Turn Left
            frontLeftMotor.setPower(1);
            frontRightMotor.setPower(1);
    
        } else {
    
            frontLeftMotor.setPower(0);
            frontRightMotor.setPower(0);
            rearLeftMotor.setPower(0);
            rearRightMotor.setPower(0);
    
       }
    */
        
 // Show the elapsed game time, wheel power, and Left/Right stick Pos.
        telemetry.addData("Status", "Run Time: " + runtime.toString());
        telemetry.addData("Motors", "front left (%.2f), front right (%.2f)", frontLeftMotorPower, frontRightMotorPower);
        telemetry.addData("Motors", "rear left (%.2f), rear right (%.2f)", rearLeftMotorPower, rearRightMotorPower);
        telemetry.addData ("Right Stick Pos", gamepad1.left_stick_y);
        telemetry.addData ("Left Stick Pos", gamepad1.right_stick_x);
        telemetry.addData ("");

        // Gamepad X, Y, A, and B buttons
        telemetry.addData ("X button", gamepad1.a);
        telemetry.addData ("Triangle button", gamepad1.y);
        telemetry.addData ("Circle button", gamepad1.b);
        telemetry.addData ("Square button", gamepad1.x);
        telemetry.update();

        
      }
    }
}
