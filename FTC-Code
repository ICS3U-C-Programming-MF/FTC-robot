package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.DistanceSensor;
import com.qualcomm.hardware.bosch.BNO055IMU;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;

@TeleOp(name="Control Robot", group="Linear OpMode")
public class Program extends LinearOpMode {
    
    private ElapsedTime runtime = new ElapsedTime();
    private DcMotor frontLeftMotor;
    private DcMotor frontRightMotor;
    private DcMotor rearLeftMotor;
    private DcMotor rearRightMotor;
    
    // Variables
    double frontLeftMotorPower;
    double frontRightMotorPower;
    double rearLeftMotorPower;
    double rearRightMotorPower;
    
    public void MoveForward(double distance) {
        double distancePerSecond = 100.0;
        long durationMs = (long)((distance / distancePerSecond) * 1000);
        frontLeftMotor.setPower(-1);
        frontRightMotor.setPower(1);
        sleep(durationMs);
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);
    }

    public void MoveBackward(double distance) {
        double distancePerSecond = 100.0;
        long durationMs = (long)((distance / distancePerSecond) * 1000);
        frontLeftMotor.setPower(1);
        frontRightMotor.setPower(-1);
        sleep(durationMs);
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);
    }

    public void RotateLeft(double angleDegrees, double power) {
        double degreesPerSecond = 215.0;
        long durationMs = (long)((Math.abs(angleDegrees) / degreesPerSecond) * 1000);
        frontLeftMotor.setPower(power);
        frontRightMotor.setPower(power);
        sleep(durationMs);
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);
    }
    
    public void RotateRight(double angleDegrees, double power) {
        double degreesPerSecond = 215.0;
        long durationMs = (long)((Math.abs(angleDegrees) / degreesPerSecond) * 1000);
        frontLeftMotor.setPower(-power);
        frontRightMotor.setPower(-power);
        sleep(durationMs);
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);
    }

      // MoveForward(90);
      // RotateLeft(100, 5);
      // RotateRight(100, 5);
      // MoveBackward(65);


@Override
    public void runOpMode() {
        
        frontLeftMotor = hardwareMap.get(DcMotor.class, "frontLeftMotor");
        frontRightMotor = hardwareMap.get(DcMotor.class, "frontRightMotor");
        rearLeftMotor = hardwareMap.get(DcMotor.class, "rearLeftMotor");
        rearRightMotor = hardwareMap.get(DcMotor.class, "rearRightMotor");
      
      // Put initialization blocks here
      waitForStart();
      
      // Put run blocks here
        frontLeftMotor.setPower(1);
        sleep(1000);
        frontLeftMotor.setPower(0);
        
        frontRightMotor.setPower(1);
        sleep(1000);
        frontRightMotor.setPower(0);
        
        rearLeftMotor.setPower(1);
        sleep(1000);
        rearLeftMotor.setPower(0);
          
        rearRightMotor.setPower(1);
        sleep(1000);
        rearRightMotor.setPower(0);
        
      
      while (opModeIsActive()) {
        // Put loop blocks here
        
        // Setup a variable for each drive wheel to save power level for telemetry
        double frontLeftMotorPower = 0;
        double frontRightMotorPower = 0;
        double rearLeftMotorPower = 0;
        double rearRightMotorPower = 0;
        double threshold = 0.2;
        double target = 1;
        
        // left stick to go forward, and right stick to turn.
        double drive = -gamepad1.left_stick_y;
        double turn  =  gamepad1.right_stick_x;
        frontLeftMotorPower  = Range.clip(drive + turn, -1.0, 1.0);
        frontRightMotorPower = Range.clip(drive - turn, -1.0, 1.0);
        
        if (Math.abs(gamepad1.left_stick_y + target) < threshold ) {

            // Move Straight
            frontLeftMotor.setPower(1);
            frontRightMotor.setPower(-1);

        } else if (Math.abs(gamepad1.left_stick_y + target) < threshold ) {

            // Move Backwards
            frontLeftMotor.setPower(-1);
            frontRightMotor.setPower(1);

        } else if (Math.abs(gamepad1.right_stick_x + target) < threshold ) {

            // Turn Right
            frontLeftMotor.setPower(1);
            frontRightMotor.setPower(-1);

        } else if (Math.abs(gamepad1.right_stick_x + target) < threshold ) {

            // Turn Left
            frontLeftMotor.setPower(-1);
            frontRightMotor.setPower(1);

        } else {

            frontLeftMotor.setPower(0);

        }
        
        // Show the elapsed game time, wheel power, and Left/Right stick Pos.
        telemetry.addData("Status", "Run Time: " + runtime.toString());
        telemetry.addData ("x button", gamepad1.x);
        telemetry.addData ("Right Stick Pos", gamepad1.left_stick_y);
        telemetry.addData ("Left Stick Pos", gamepad1.right_stick_x);
        telemetry.addData("Motors", "front left (%.2f), front right (%.2f)", frontLeftMotorPower, frontRightMotorPower);
        telemetry.addData("Motors", "rear left (%.2f), rear right (%.2f)", rearLeftMotorPower, rearRightMotorPower);
        telemetry.update();
        
      }
    }
}
